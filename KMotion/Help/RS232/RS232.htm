<!DOCTYPE html>
<html>
<head>

<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
<meta http-equiv="Pragma" content="no-cache"/>
<meta http-equiv="Expires" content="0"/>

<meta name="keywords" content="ethernet 16-axis controller, cnc control, motion control, cnc boards, 4-axis, 8-axis, stepper, brushless, DC motor, servo, encoder, adc, dac, motion controller, automated motion, manufacturing, Mach3">
<meta name="description" content="Manufacturer of premium motion control products for CNC Manufacturing, Robotics and Automation">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta http-equiv="Content-Language" content="en-us">

<title>RS232 with KFLOP</title>

<link rel="stylesheet" type="text/css" href="../css/style.css">
<link rel="stylesheet" href="../css/prism.css" data-noprefix />
<script src="../js/prism.js"></script>
</head>

<body>

<div id="logo"><a href="../index.htm"></a></div>

<div id="home">
<a href="../index.htm">Table of contents</a> |  
	<script>
		if (navigator.userAgent.indexOf("NT 6.2") == -1){
			document.write('<a href="https://www.dynomotion.com">Dynomotion home page</a>')
		} else {
			document.write('<a href="https://www.dynomotion.com" target="_blank">Dynomotion home page</a>')
		}
	</script>
</div>
	
<div id="searchNav">

	<div class="gcse-search">
					<script>
					  if (document.location.protocol  ==  'https:') {
					  (function() {
					  var cx = '012657033059195044748:9fmjmlufts0';
					  var gcse = document.createElement('script');
					  gcse.type = 'text/javascript';
					  gcse.async = true;
					  gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
					      '//cse.google.com/cse.js?cx=' + cx;
					  var s = document.getElementsByTagName('script')[0];
					  s.parentNode.insertBefore(gcse, s);
					})();
					  }
				      </script> 
				      <gcse:search> </gcse:search>  

	       </div>
</div>	

	


<div id="google_translate_element" style="background: transparent;" align="right"><script type="text/javascript">
if (navigator.userAgent.indexOf("NT 6.2") == -1) {
		function googleTranslateElementInit() {
	  new google.translate.TranslateElement({pageLanguage: 'en', includedLanguages: 'en,de,fr,it,es,pt,ru,uk,ar,zh-CN,zh-TW,ko,iw,hi,ja,tr', layout: google.translate.TranslateElement.InlineLayout.SIMPLE}, 'google_translate_element');
		}						}
	</script>
	<script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit">
	</script>
</div>		
<div id="main">

<h1>KFLOP/Kogna - RS232</h1>

<h2>RS232</h2>

<p>KFLOP/Kogna contains a UART that can allow KFLOP/Kogna User C Programs 
to perform serial communication with other 3rd party devices.</p>

<p>KFLOP/Kogna itself contains the serial communication UART but 
does not have the circuitry to drive or receive the signals at the +3 to 25V to 
-3 to -25V voltages levels specified by the RS232 standard. The transmit 
and receive signals to/from KFLOP/Kogna are 3.3V LVTTL logic signals. Where a 
low logic level (&lt;0.4V) represents the RS232 Space Level (&gt;+3V) and a high 
logic level represents the RS232 Mark Level (&lt; -3V).</p>

<p><em><strong>Note that the signals that the signals coming 
directly from KFLOP/Kogna are not RS232 compatible. Connecting KFLOP/Kogna inputs 
directly to RS232 is likely to cause damage.</strong></em></p>
<p>Some serial devices may be compatible with 3.3V logic. 
Also many 3rd party converters are available. A Internet search found this 
one (we haven't tested it).</p>

<p><a href="http://www.commfront.com/TTL-RS232-RS485-Serial-Converters/RS232-TTL3.3V-Converter.htm">
http://www.commfront.com/TTL-RS232-RS485-Serial-Converters/RS232-TTL3.3V-Converter.htm</a></p>
<p>Our Kanalog board has a LVTTL to converter on board (see next section below).</p>

<p><img src="RS232KFLOPJ7.png" width="563" height="413" alt="RS232 KFLOP JP7" /></p>
<p><img src="../SchematicsKFLOP/JP7Photo.JPG" width="418" height="139" alt="JP7Photo" /></p>

<h2>KFLOP/Kogna + Kanalog - RS232</h2>

<p>Kanalog contains circuitry to convert the KFLOP/Kogna UART logic 
levels to standard RS232 voltage levels. The RS232 signals are accessible 
from JP10 which is a standard RJ12 phone jack.</p>

<p>The pinout is shown below. The pinout is designed to 
be 1:1 compatible with certain PLC devices. Note that a phone cable with 
all 6 wires populated is required in order to make the pin 1 ground connection.</p>

<p><img src="RS232KanalogJP10.png" width="364" height="260" alt="RS232KanalogJP10" /></p>

<h2>KFLOP/Kogna UART Software</h2>

<p>The KFLOP/Kogna FPGA implements a programmable baud rate UART 
with double buffering of 1 character on transmit and receive. Currently a 
KFLOP/Kogna User C program must be used to make use of the UART. It is up to the 
User to program whatever is necessary to control any specific device.</p>

<p>KFLOP/Kogna User Programs with 1 active thread execute every 
180us. (See <a href="../Multitasking.htm">here</a> for more info). This 
allows rates up t0 38400 baud without loss if a character is read every time 
slice (10 bits at 38400Hz = 260us). Data transmitted and 
received is always 8 bits. If parity is required it should be handled by 
the User C program.</p>

<p>To set the baud rate write a defined 8-bit baud rate divisor to an FPGA Register (RS232_BAUD_REG )</p>

<p>To transmit a character an 8-bit character is written to an FPGA register (RS232_DATA).</p>

<p>To receive a character read an 8-bit value from an FPGA register (RS232_DATA )</p>

<p>A status register (RS232_STATUS) provides 2 bits of status 
that can be used to determine if a character has been received 
(RS232_DATA_READY) and if it is possible to transmit a character 
(RS232_TRANSMIT_FULL)</p>

<p>The following definitions have been added to the KMotionDef.h file.</p>

<pre>
	<code class="language-c">
	//RS232 FPGA Register Definitions

	#define RS232_STATUS 0xc1 // Status Reg Address
	#define RS232_DATA 0xc0 // 8 bit data read/write reg address
	#define RS232_DATA_READY 0x01 // Data ready to read status mask
	#define RS232_TRANSMIT_FULL 0x02// Transmit buffer full status mask

	#define RS232_BAUD_REG 0xc1 // Set Baud rate 8-bit divisor Reg Address
	#define RS232_BAUD_115200 ((16666666/115200/16)-1)// 8-bit divisor value to set 115200 baud
	#define RS232_BAUD_57600 ((16666666/57600/16)-1) // 8-bit divisor value to set 57600 baud
	#define RS232_BAUD_38400 ((16666666/38400/16)-1) // 8-bit divisor value to set 38400 baud
	#define RS232_BAUD_19200 ((16666666/19200/16)-1) // 8-bit divisor value to set 19200 baud
	#define RS232_BAUD_9600 ((16666666/9600/16)-1) // 8-bit divisor value to set 9600 baud
	#define RS232_BAUD_4800 ((16666666/4800/16)-1) // 8-bit divisor value to set 4800 baud
		</code>
	</pre>
	
<p>Note if KFLOP/Kogna is to be used without Kanalog the UART IO 
pins must be activated by executing the following line of code one time:</p>

<pre>
	<code class="language-c">
	FPGA(KAN_TRIG_REG)=2;
	</code>
</pre>

<p><strong>Note:</strong> The techniques shown below may be used but a 
new simpler and buffered method is now available.<br />
See the \C Programs\RS232\BufferedRS232.c example.</p>

<h2>Transmit Example (RS232Send.c example)</h2>

<pre>
	<code class="language-c">
	#include &quot;KMotionDef.h&quot;
	
	void SendChar(char c)
	{
 		while (FPGA(RS232_STATUS) &amp; RS232_TRANSMIT_FULL);
 		FPGA(RS232_DATA) = c;
	}

	main()
	{
 		int i;
 		SetBitDirection(45,1);
 		FPGA(RS232_BAUD_REG) = RS232_BAUD_38400;
 		// FPGA(KAN_TRIG_REG) = 1; // enable Kanalog to get RS232 working
 		for (i=0;i&lt;100;i++)
 		{
 			SendChar('A');
 		}
	}
	</code>
</pre>

<h2>Receive Example (RS232Read.c example)</h2>

<pre>
	<code class="language-c">
	#include &quot;KMotionDef.h&quot;

	void ReceiveChar()
	{
 		// wait for data in buffer
 		while ((FPGA(RS232_STATUS) &amp; 1)==0);
 		return FPGA(RS232_DATA);
	}

	main()
	{
 		SetBitDirection(45,1);
 		FPGA(RS232_BAUD_REG) = RS232_BAUD_38400;
 		// FPGA(KAN_TRIG_REG) = 1; // enable Kanalog to get RS232 working
 		for (;;)
 		{
 			while ((FPGA(RS232_STATUS) &amp; RS232_DATA_READY) == 0) ;
 			printf(&quot;%X\n&quot;,ReceiveChar());
 		}
	} 
	</code>
</pre>

	</div>
	<p>&nbsp;</p>
</body>

</html>